/**
 * @file OptionNode.tsx
 * @description Elite component for logical options generated by DecisionNode.
 * @version 4.0.0 - Modular TypeScript architecture with enterprise patterns
 */

import { CornerDownRight, Check, X } from 'lucide-react';
import React, { useRef, useMemo, useCallback, useState, useEffect } from 'react';
import { Position, useUpdateNodeInternals } from 'reactflow';

// Store imports
import { useNodeData } from '@/stores/selectors';
import useFlowStore from '@/stores/use-flow-store';
// Utils
import { formatDateRelative } from '@/utils/date.js';
import { useRenderTracker } from '@/utils/renderTracker';

import Tooltip from '../../ui/ToolTip';

// Local imports
import OptionNodeHandle from './components/OptionNodeHandle';
import OptionNodeIcon from './components/OptionNodeIcon';
import { NODE_CONFIG } from './constants';
import {
  getHandleColorFromLabel,
  calculateNodeClasses,
  calculateNodeStyle,
  getAriaLabel,
} from './helpers';
import {
  useNodeEffects,
  useNodeCallbacks,
  useKeyboardHandlers,
  useHoverState,
  useFocusState,
} from './hooks';
import type { OptionNodeProps } from './types';

// Styles
import './OptionNode.css';

// Type for FlowStore selectors
interface FlowStoreState {
  updateNodeData: (id: string, data: Record<string, unknown>) => void;
  setNodeEditing: (id: string, isEditing: boolean) => void;
  isUltraPerformanceMode: boolean;
}

/**
 * OptionNode Component
 * Professional implementation following Google/Meta/Apple standards
 */
const OptionNodeComponent: React.FC<OptionNodeProps> = ({
  id,
  data,
  selected = false,
  isConnectable = true,
}) => {
  useRenderTracker('OptionNode');

  // ==================== STATE ====================
  const [currentInstruction, setCurrentInstruction] = useState(
    data?.instruction ?? NODE_CONFIG.DEFAULT_INSTRUCTION,
  );

  // ==================== REFS ====================
  const nodeRef = useRef<HTMLDivElement | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement | null>(null);

  // ==================== HOOKS ====================
  const updateNodeInternals = useUpdateNodeInternals();
  // OPTIMIZED: Removed useReactFlow() to prevent re-renders
  // const reactFlowInstance = useReactFlow();

  // ==================== STORE - OPTIMIZED SELECTORS ====================
  const updateNodeData = useFlowStore((state) => (state as FlowStoreState).updateNodeData);
  const setNodeEditing = useFlowStore((state) => (state as FlowStoreState).setNodeEditing);

  const isUltraPerformanceModeGlobal = useFlowStore(
    (state) => (state as FlowStoreState).isUltraPerformanceMode,
  );

  const nodeData = useNodeData(id) as Record<string, unknown> | undefined;
  const isEditing = (nodeData?.isEditing ?? false) as boolean;
  const isUltraPerformanceMode = data?.isUltraPerformanceMode ?? isUltraPerformanceModeGlobal;

  // ==================== HOVER & FOCUS ====================
  const { isHovered: _isHovered, handleMouseEnter, handleMouseLeave } = useHoverState();
  const { isFocused: _isFocused, handleFocus, handleBlur } = useFocusState();

  // ==================== DESTRUCTURE DATA ====================
  const { label, instruction, sourceNode, lastUpdated, color, index } = data ?? {};

  // ==================== LABEL EDITING STATE ====================
  const [isEditingLabel, setIsEditingLabel] = useState(false);
  const [currentLabel, setCurrentLabel] = useState(label ?? 'Opci√≥n');
  const labelInputRef = useRef<HTMLInputElement>(null);

  // Update currentLabel when label prop changes
  useEffect(() => {
    setCurrentLabel(label ?? 'Opci√≥n');
  }, [label]);

  // ==================== ULTRA-OPTIMIZED DERIVED VALUES ====================
  // PERFORMANCE: Memoize nodeColor to prevent OptionNodeHandle re-renders
  // FIXED: Use color from DecisionNode data first, fallback to label-based calculation
  const nodeColor = useMemo(() => {
    // Priority 1: Use color passed from DecisionNode (this ensures handle color sync)
    if (color) {
      return color;
    }
    // Priority 2: Fallback to label-based calculation for standalone OptionNodes
    return getHandleColorFromLabel(label ?? currentLabel ?? 'default');
  }, [color, label, currentLabel]);

  // PERFORMANCE: Memoize isConnectable to prevent OptionNodeHandle re-renders
  const isConnectableMemo = useMemo(() => {
    return !isEditing && !isUltraPerformanceMode;
  }, [isEditing, isUltraPerformanceMode]);

  // PERFORMANCE: Memoize handle props to prevent unnecessary re-renders
  const handleProps = useMemo(
    () => ({
      isConnectable: isConnectableMemo,
      isEditing,
      isUltraPerformanceMode,
      color: nodeColor,
      label: label ?? currentLabel,
    }),
    [isConnectableMemo, isEditing, isUltraPerformanceMode, nodeColor, label, currentLabel],
  );

  const nodeClasses = useMemo(
    () =>
      calculateNodeClasses({
        selected,
        _sourceNode: sourceNode,
        isConnectable: isConnectableMemo,
        isEditing,
        isUltraPerformanceMode,
      }),
    [selected, sourceNode, isConnectableMemo, isEditing, isUltraPerformanceMode],
  );

  const nodeStyle = useMemo(
    () =>
      calculateNodeStyle({
        selected,
        sourceNode,
        isConnectable,
        color: nodeColor,
        label,
      }),
    [selected, sourceNode, isConnectable, nodeColor, label],
  );

  const ariaLabel = useMemo(
    () => getAriaLabel(label, instruction, sourceNode),
    [label, instruction, sourceNode],
  );

  // ==================== CALLBACKS ====================
  const callbacks = useNodeCallbacks({
    currentInstruction,
    setCurrentInstruction,
    updateNodeData,
    id,
    instruction,
    sourceNode,
    textareaRef,
    setNodeEditing,
    isUltraPerformanceMode,
    // reactFlowInstance, // REMOVED: Not used in the hook
    label,
    index,
  });

  // ==================== LABEL EDITING CALLBACKS ====================
  const startLabelEditing = useCallback(() => {
    // console.log('üéØ startLabelEditing called - activating label editing mode'); // DISABLED
    // console.log('üéØ Current state:', { isEditingLabel, label, currentLabel }); // DISABLED
    setIsEditingLabel(true);
    setTimeout(() => {
      if (labelInputRef.current) {
        labelInputRef.current.focus();
        labelInputRef.current.select();
        // console.log('üéØ Label input focused and selected successfully'); // DISABLED
      } else {
        console.error('‚ùå labelInputRef.current is null - input not found');
      }
    }, 0);
  }, []);

  const finishLabelEditing = useCallback(() => {
    // console.log('üéØ finishLabelEditing called:', { currentLabel, label }); // DISABLED
    const trimmedLabel = currentLabel.trim() ?? 'Opci√≥n';
    if (trimmedLabel && trimmedLabel !== label) {
      // console.log('‚úÖ Label changed, updating:', { old: label, new: trimmedLabel }); // DISABLED

      // Update local OptionNode data
      updateNodeData(id, {
        label: trimmedLabel,
        instruction: trimmedLabel,
        lastUpdated: new Date().toISOString(),
      });
      setNodeEditing(id, false);

      // Update parent DecisionNode
      // console.log('üì§ Calling updateParentDecisionNode with:', trimmedLabel); // DISABLED
      callbacks.updateParentDecisionNode(trimmedLabel);
    } else {
      // console.log('‚è≠Ô∏è No change in label, skipping update'); // DISABLED
    }
    setIsEditingLabel(false);
  }, [currentLabel, label, id, updateNodeData, callbacks, setNodeEditing]);

  const cancelLabelEditing = useCallback(() => {
    setCurrentLabel(label ?? 'Opci√≥n');
    setIsEditingLabel(false);
  }, [label]);

  const handleLabelChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setCurrentLabel(e.target.value);
  }, []);

  const handleLabelKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        finishLabelEditing();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelLabelEditing();
      }
    },
    [finishLabelEditing, cancelLabelEditing],
  );

  const { handleKeyDown } = useKeyboardHandlers({
    isEditing,
    startEditing: callbacks.startEditing,
    finishEditing: callbacks.finishEditing,
    cancelEditing: callbacks.cancelEditing,
    navigateToParent: callbacks.navigateToParent,
    sourceNode,
  });

  const handleDoubleClick = useCallback(() => {
    if (!isEditing && !isUltraPerformanceMode) {
      callbacks.startEditing();
    }
  }, [isEditing, isUltraPerformanceMode, callbacks]);

  // ==================== EFFECTS ====================
  useNodeEffects({
    isEditing,
    instruction,
    setCurrentInstruction,
    textareaRef,
    nodeRef,
    id,
    updateNodeInternals,
  });

  // ==================== RENDER ====================
  return (
    <div
      ref={nodeRef}
      className={nodeClasses}
      style={nodeStyle}
      onDoubleClick={handleDoubleClick}
      onKeyDown={handleKeyDown}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      onFocus={handleFocus}
      onBlur={handleBlur}
      tabIndex={0}
      role='treeitem'
      aria-label={ariaLabel}
      aria-selected={selected}
      aria-expanded={isEditing}
      aria-describedby={`option-node-description-${id}`}
    >
      {/* Top Handle */}
      <OptionNodeHandle
        type='target'
        position={Position.Top}
        id='target'
        isConnectable={isConnectable && !isEditing}
        isEditing={isEditing}
        isUltraPerformanceMode={isUltraPerformanceMode}
        color={nodeColor}
        label={label}
      />

      {/* Main Content Container */}
      <div className='option-node__content'>
        {/* Header Section */}
        <div className='option-node__header'>
          <div className='option-node__title'>
            <OptionNodeIcon label={label} isUltraPerformanceMode={isUltraPerformanceMode} />
            {isEditingLabel ? (
              <input
                ref={labelInputRef}
                type='text'
                value={currentLabel}
                onChange={handleLabelChange}
                onKeyDown={handleLabelKeyDown}
                onBlur={finishLabelEditing}
                className='option-node__label-input'
                placeholder='Nombre de la opci√≥n'
                maxLength={50}
              />
            ) : (
              <div className='option-node__label-container'>
                <span
                  className='option-node__label-text'
                  role='button'
                  tabIndex={0}
                  onDoubleClick={(e) => {
                    e.stopPropagation();
                    // console.log('üéØ Double click detected on label'); // DISABLED
                    startLabelEditing();
                  }}
                  onClick={(e) => {
                    e.stopPropagation();
                    // console.log('üéØ Single click on label'); // DISABLED
                  }}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      e.stopPropagation();
                      startLabelEditing();
                    }
                  }}
                  title='Doble clic para editar nombre'
                  style={{ cursor: 'pointer', userSelect: 'none' }}
                >
                  {label ?? 'Opci√≥n'}
                </span>
                <button
                  className='option-node__edit-label-btn'
                  onClick={(e) => {
                    e.stopPropagation();
                    // console.log('üéØ Edit button clicked'); // DISABLED
                    startLabelEditing();
                  }}
                  title='Editar nombre de la opci√≥n'
                  aria-label='Editar nombre'
                >
                  ‚úèÔ∏è
                </button>
              </div>
            )}
          </div>

          {/* Parent Navigation Button */}
          {sourceNode && !isUltraPerformanceMode && (
            <Tooltip content={`Ir a nodo padre: ${sourceNode.slice(0, 8)}...`} position='top'>
              <button
                onClick={callbacks.navigateToParent}
                className='option-node__parent-link'
                aria-label='Ver nodo padre'
              >
                <CornerDownRight size={14} />
              </button>
            </Tooltip>
          )}
        </div>

        {/* Instruction Wrapper */}
        <div className='option-node__instruction-wrapper'>
          {isEditing ? (
            <textarea
              ref={textareaRef}
              className='option-node__instruction-textarea'
              value={currentInstruction}
              onChange={callbacks.handleInstructionChange}
              onBlur={callbacks.finishEditing}
              onKeyDown={handleKeyDown}
              placeholder='Escribe las instrucciones para esta opci√≥n...'
              aria-label='Instrucciones para esta opci√≥n'
            />
          ) : (
            <div
              className='option-node__instruction-text'
              onClick={!isUltraPerformanceMode ? callbacks.startEditing : undefined}
              onKeyDown={(e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  e.preventDefault();
                  callbacks.startEditing();
                }
              }}
              role='button'
              tabIndex={0}
            >
              {/* Evitar redundancia: si instruction es igual al label, mostrar texto descriptivo */}
              {instruction && instruction !== label && instruction !== currentLabel
                ? instruction
                : NODE_CONFIG.DEFAULT_INSTRUCTION}
            </div>
          )}
        </div>

        {/* Action Buttons in Edit Mode */}
        {isEditing && (
          <div className='option-node__actions'>
            <Tooltip content='Cancelar (Esc)' position='top'>
              <button
                onClick={callbacks.cancelEditing}
                className='option-node__button option-node__button--cancel'
                aria-label='Cancelar edici√≥n'
              >
                <X size={14} />
                <span>Cancelar</span>
              </button>
            </Tooltip>
            <Tooltip content='Guardar (Ctrl+Enter)' position='top'>
              <button
                onClick={callbacks.finishEditing}
                className='option-node__button option-node__button--save'
                aria-label='Guardar cambios'
              >
                <Check size={14} />
                <span>Guardar</span>
              </button>
            </Tooltip>
          </div>
        )}

        {/* Footer Section */}
        {!isUltraPerformanceMode && !isEditing && lastUpdated && (
          <div className='option-node__footer'>
            <span className='option-node__timestamp'>
              Actualizado: {formatDateRelative(lastUpdated)}
            </span>
          </div>
        )}
      </div>

      {/* Top Handle (Input) - PERFORMANCE OPTIMIZED */}
      <OptionNodeHandle type='target' position={Position.Top} id='target' {...handleProps} />

      {/* Bottom Handle (Output) - PERFORMANCE OPTIMIZED */}
      <OptionNodeHandle type='source' position={Position.Bottom} id='source' {...handleProps} />

      {/* Accessibility Description */}
      <span className='sr-only' id={`option-node-description-${id}`}>
        Nodo de opci√≥n: {label ?? 'Opci√≥n sin etiqueta'}. Instrucci√≥n:{' '}
        {instruction ?? NODE_CONFIG.DEFAULT_INSTRUCTION}. Deriva del nodo de decisi√≥n:{' '}
        {sourceNode ? `${sourceNode.slice(0, 8)}...` : 'Desconocido'}.
        {lastUpdated && ` √öltima actualizaci√≥n: ${formatDateRelative(lastUpdated)}.`}
      </span>
    </div>
  );
};

// ==================== ULTRA-OPTIMIZED MEMOIZED EXPORT ====================
const OptionNode = React.memo(OptionNodeComponent, (prevProps, nextProps) => {
  // PERFORMANCE: Ultra-fast identity checks first
  if (prevProps.id !== nextProps.id) return false;
  if (prevProps.selected !== nextProps.selected) return false;
  if (prevProps.isConnectable !== nextProps.isConnectable) return false;

  // PERFORMANCE: Null/undefined checks to avoid unnecessary object access
  const prevData = prevProps.data;
  const nextData = nextProps.data;

  if (prevData === nextData) return true; // Same reference = no change
  if (!prevData || !nextData) return false; // One is null/undefined

  // PERFORMANCE: Only check properties that actually affect rendering
  return (
    prevData.label === nextData.label &&
    prevData.instruction === nextData.instruction &&
    prevData.color === nextData.color &&
    prevData.index === nextData.index &&
    prevData.isEditing === nextData.isEditing &&
    prevData.lastUpdated === nextData.lastUpdated
    // REMOVED: sourceNode (doesn't affect visual rendering)
  );
});

export default OptionNode;
